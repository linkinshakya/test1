<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Open-City Sandbox (GTA‑style demo) — VACT</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="theme-color" content="#0f172a" />
<style>
  :root{
    --bg:#0b1220; --fg:#e5e7eb; --muted:#94a3b8; --accent:#10b981; --danger:#ef4444; --panel:#0f172a;
    --shadow: 0 12px 24px rgba(0,0,0,.25);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial}
  #hud{position:fixed;inset:12px auto auto 12px;z-index:10;display:grid;gap:8px;min-width:240px}
  .card{background:rgba(15,23,42,.7);backdrop-filter: blur(6px);border:1px solid rgba(255,255,255,.06);padding:10px 12px;border-radius:14px;box-shadow:var(--shadow)}
  .row{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#0b1327;border:1px solid rgba(255,255,255,.06);font-size:12px;color:var(--muted)}
  #tips{font-size:12px;line-height:1.35;color:var(--muted)}
  #mission{font-weight:600}
  #notice{color:#fef08a;font-size:12px}
  #speed{font-variant-numeric: tabular-nums}
  #renderer{position:fixed;inset:0}
  /* Mobile controls */
  #touch{position:fixed;inset:auto 0 0 0;display:flex;justify-content:space-between;padding:10px;pointer-events:none}
  .pad{pointer-events:auto;display:grid;grid-template-columns:repeat(3,56px);grid-template-rows:repeat(2,56px);gap:10px}
  .btn{height:56px;width:56px;border-radius:14px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);
       display:flex;align-items:center;justify-content:center;font-weight:700;color:#cbd5e1;user-select:none;box-shadow:var(--shadow)}
  .btn:active{transform:scale(.98)}
  .btn.big{width:80px}
  .ghost{opacity:.6}
  /* Hide touch UI on wide screens */
  @media (min-width: 900px){ #touch{display:none} }
  /* Small screens */
  @media (max-width:380px){ .btn{height:48px;width:48px} .btn.big{width:64px} .pad{gap:8px;grid-template-columns:repeat(3,48px)} }
  /* Overlay title */
  #brand{position:fixed;right:12px;top:12px;z-index:11}
  #brand .logo{padding:10px 14px;border-radius:14px;background:linear-gradient(180deg,#0b1327,#0a1020);border:1px solid rgba(255,255,255,.06);box-shadow:var(--shadow);font-weight:700}
  a{color:#93c5fd;text-decoration:none}
</style>
</head>
<body>
<div id="brand">
  <div class="logo">VACT • Open‑City Sandbox</div>
</div>

<div id="hud" class="card">
  <div class="row">
    <div class="pill">Mode: <span id="mode">Driving</span></div>
    <div class="pill">Speed: <span id="speed">0</span> km/h</div>
  </div>
  <div id="mission" class="card">Mission: Drive to the green beacon (0/5)</div>
  <div id="notice" class=""></div>
  <div id="tips" class="card">
    Desktop: <b>W/S</b> throttle, <b>A/D</b> steer, <b>Space</b> brake, <b>E</b> enter/exit.<br/>
    Mobile: use on‑screen arrows + <b>ACT</b> to enter/exit.<br/>
    This is an original demo (no GTA assets). Extend as you wish.
  </div>
</div>

<canvas id="renderer"></canvas>

<!-- Touch controls -->
<div id="touch">
  <div class="pad">
    <div class="btn ghost"></div>
    <div class="btn" data-k="KeyW">▲</div>
    <div class="btn ghost"></div>
    <div class="btn" data-k="KeyA">◀</div>
    <div class="btn" data-k="KeyS">▼</div>
    <div class="btn" data-k="KeyD">▶</div>
  </div>
  <div class="pad" style="grid-template-columns:repeat(2,80px)">
    <div class="btn big" data-k="Space">BRAKE</div>
    <div class="btn big" data-k="KeyE">ACT</div>
  </div>
</div>

<!-- three.js (global build) -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(() => {
  const { Scene, PerspectiveCamera, WebGLRenderer, Color, Vector2, Vector3, AmbientLight, DirectionalLight,
          PlaneGeometry, MeshStandardMaterial, Mesh, BoxGeometry, Group, MathUtils, Raycaster, SphereGeometry } = THREE;

  // ----- Core setup
  const canvas = document.getElementById('renderer');
  const scene = new Scene();
  scene.background = new Color(0x0b1220);

  const camera = new PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 12, 16);

  const renderer = new WebGLRenderer({ canvas, antialias: true, powerPreference:'high-performance' });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));

  // Lighting
  scene.add(new AmbientLight(0xffffff, 0.65));
  const sun = new DirectionalLight(0xffffff, 0.8);
  sun.position.set(20, 40, 10);
  scene.add(sun);

  // HUD refs
  const speedEl = document.getElementById('speed');
  const modeEl = document.getElementById('mode');
  const missionEl = document.getElementById('mission');
  const noticeEl = document.getElementById('notice');

  // ----- City generation
  const world = {
    size: 600,        // overall half-size
    block: 22,        // block size (street to street)
    road: 8,          // road width
    buildings: [],
    beacons: [],
  };

  function makeGround(){
    // Two-tone grid look: roads are darker, blocks are lighter
    const g = new PlaneGeometry(world.size, world.size, 1, 1);
    const m = new MeshStandardMaterial({ color: 0x0f172a, roughness: 1, metalness: 0 });
    const ground = new Mesh(g, m);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Paint roads & lanes using boxes
    const roadMat = new MeshStandardMaterial({ color: 0x111827, roughness: .9 });
    const laneMat = new MeshStandardMaterial({ color: 0x374151, roughness: .9 });
    const blockMat = new MeshStandardMaterial({ color: 0x1f2937, roughness: .95 });

    // Draw a grid of roads + blocks
    const cityExtent = 240;
    for (let x = -cityExtent; x <= cityExtent; x += world.block){
      // vertical road strip
      addStrip(x, 'z', roadMat, world.road, cityExtent*2 + world.block);
      // lanes offset for visual detail
      addStrip(x-2, 'z', laneMat, 1.2, cityExtent*2 + world.block);
      addStrip(x+2, 'z', laneMat, 1.2, cityExtent*2 + world.block);
    }
    for (let z = -cityExtent; z <= cityExtent; z += world.block){
      addStrip(z, 'x', roadMat, world.road, cityExtent*2 + world.block);
      addStrip(z-2, 'x', laneMat, 1.2, cityExtent*2 + world.block);
      addStrip(z+2, 'x', laneMat, 1.2, cityExtent*2 + world.block);
    }

    // fill blocks with buildings
    const rng = (a,b)=>a + Math.random()*(b-a);
    const probs = [0.85, 0.65, 0.45]; // density falloff away from center
    for (let gx = -cityExtent; gx < cityExtent; gx += world.block){
      for (let gz = -cityExtent; gz < cityExtent; gz += world.block){
        const cx = gx + world.block/2;
        const cz = gz + world.block/2;
        if (Math.abs(cx) < world.road/2 || Math.abs(cz) < world.road/2) continue;

        // Skip if within road widths
        if (Math.abs(cx % world.block) < world.road || Math.abs(cz % world.block) < world.road) continue;

        // distance from center affects density
        const d = Math.hypot(cx, cz);
        const p = d < 120 ? probs[0] : d < 200 ? probs[1] : probs[2];
        if (Math.random() > p) continue;

        const bW = rng(6, 10);
        const bD = rng(6, 10);
        const bH = rng(8, 40);
        const geo = new BoxGeometry(bW, bH, bD);
        const hue = MathUtils.randFloat(200, 220); // bluish palette
        const sat = MathUtils.randFloat(12, 24);
        const lit = MathUtils.randFloat(40, 58);
        const col = new Color(`hsl(${hue}, ${sat}%, ${lit}%)`);
        const mat = new MeshStandardMaterial({ color: col, roughness:.95, metalness:.05 });
        const mesh = new Mesh(geo, mat);
        mesh.position.set(cx + MathUtils.randFloatSpread(4), bH/2, cz + MathUtils.randFloatSpread(4));
        mesh.castShadow = false; mesh.receiveShadow = true;
        scene.add(mesh);
        world.buildings.push({ mesh, min:new Vector3(), max:new Vector3() });
      }
    }

    function addStrip(at, axis, mat, width, length){
      const geo = axis==='z' ? new BoxGeometry(width, .2, length) : new BoxGeometry(length, .2, width);
      const mesh = new Mesh(geo, mat);
      mesh.position[axis==='z' ? 'x' : 'z'] = at;
      mesh.position.y = .01;
      scene.add(mesh);
    }
  }
  makeGround();

  // ----- Player & vehicle
  const keys = new Set();
  const input = { fwd:0, turn:0, brake:0, action:false };

  function onKey(e, down){
    const k = e.code;
    if (down) keys.add(k); else keys.delete(k);
    input.fwd  = (keys.has('KeyW')||keys.has('ArrowUp')) - (keys.has('KeyS')||keys.has('ArrowDown'));
    input.turn = (keys.has('KeyD')||keys.has('ArrowRight')) - (keys.has('KeyA')||keys.has('ArrowLeft'));
    input.brake = keys.has('Space')?1:0;
    if (down && k === 'KeyE'){ input.action = true; }
  }
  addEventListener('keydown', e=>onKey(e,true));
  addEventListener('keyup',   e=>onKey(e,false));

  // Touch buttons -> synthesize key presses
  document.querySelectorAll('.btn[data-k]').forEach(btn=>{
    const code = btn.getAttribute('data-k');
    const press = (d)=>{ onKey({code}, d); if (d===true && code==='KeyE'){ input.action=true; } };
    btn.addEventListener('touchstart', e=>{ e.preventDefault(); press(true); btn.classList.add('active'); }, {passive:false});
    btn.addEventListener('touchend',   e=>{ e.preventDefault(); press(false); btn.classList.remove('active'); }, {passive:false});
  });

  // Car entity
  function makeCar(){
    const car = new Group();
    const body = new Mesh(new BoxGeometry(1.8, .6, 3.2), new MeshStandardMaterial({ color:0x10b981, roughness:.7 }));
    body.position.y = .5;
    const roof = new Mesh(new BoxGeometry(1.6, .4, 1.6), new MeshStandardMaterial({ color:0x0ea5e9, roughness:.8 }));
    roof.position.set(0, .9, -.2);
    car.add(body, roof);

    car.position.set(0, 0, 0);
    scene.add(car);

    return {
      obj: car,
      vel: new Vector2(0,0),     // forward speed (z local) & lateral drift (x local)
      heading: 0,                // radians (y-rotation)
      maxSpeed: 55,              // km/h
      accel: 18,                 // km/h per second
      drag: 4,                   // speed decay
      steerRate: Math.PI * 0.9,  // radians/s at 100% steer
      handBrake: 0,
      bbox: new BoxGeometry(2.2, 1.2, 3.6), // for collisions (approx)
      getSpeedKmh(){ return Math.abs(this.vel.y); },
      update(dt){
        // throttle/brake to change vel.y (forward)
        const targetAcc = input.fwd * this.accel - this.drag * Math.sign(this.vel.y);
        this.vel.y += targetAcc * dt;
        // clamp speed
        const max = this.maxSpeed; // km/h
        this.vel.y = MathUtils.clamp(this.vel.y, -max, max);

        // steering depends on current forward speed
        const steer = input.turn * this.steerRate * (this.vel.y/Math.max(max,1));
        this.heading -= steer * dt;

        // braking
        const brakeForce = input.brake ? 30 : 0;
        if (brakeForce) {
          const sgn = Math.sign(this.vel.y);
          this.vel.y -= brakeForce * sgn * dt;
          if (Math.sign(this.vel.y) !== sgn) this.vel.y = 0; // prevent sign flip due to over-brake
        }

        // world delta from local (x,z)
        const vz = (this.vel.y/3.6) * dt; // m/s
        const dx = Math.sin(this.heading) * vz;
        const dz = Math.cos(this.heading) * vz;

        // tentative move
        const obj = this.obj;
        const prev = obj.position.clone();
        obj.position.x += dx;
        obj.position.z += dz;
        obj.rotation.y = this.heading;

        // collisions with buildings (AABB vs car footprint)
        if (collidesWithBuildings(obj.position, this.heading, 1.0, 1.8)) {
          // revert and null speed on hit
          obj.position.copy(prev);
          this.vel.y = 0;
        }
      }
    }
  }

  function collidesWithBuildings(pos, heading, halfW, halfL){
    // Fast AABB overlap using oriented rectangle approximated as AABB (cheap but OK)
    const carMin = new Vector3(pos.x - halfW, 0, pos.z - halfL);
    const carMax = new Vector3(pos.x + halfW, 2, pos.z + halfL);

    for (const b of world.buildings){
      b.mesh.geometry.computeBoundingBox();
      const bb = b.mesh.geometry.boundingBox;
      const min = b.min.copy(bb.min).applyMatrix4(b.mesh.matrixWorld);
      const max = b.max.copy(bb.max).applyMatrix4(b.mesh.matrixWorld);
      if ( (carMin.x <= max.x && carMax.x >= min.x) &&
           (carMin.y <= max.y && carMax.y >= min.y) &&
           (carMin.z <= max.z && carMax.z >= min.z) ) {
        return true;
      }
    }
    return false;
  }

  // Ped (on foot)
  function makePed(){
    const ped = new Group();
    const body = new Mesh(new BoxGeometry(.6, 1.4, .4), new MeshStandardMaterial({ color:0xf59e0b, roughness:.8 }));
    body.position.y = .7;
    const head = new Mesh(new SphereGeometry(.22, 16, 16), new MeshStandardMaterial({ color:0xffe4b5 }));
    head.position.y = 1.55;
    ped.add(body, head);
    ped.position.set(2.5, 0, -2.5);
    scene.add(ped);

    return {
      obj: ped,
      speed: 8,   // km/h
      update(dt){
        const v = new Vector2(
          (keys.has('KeyD')||keys.has('ArrowRight')) - (keys.has('KeyA')||keys.has('ArrowLeft')),
          (keys.has('KeyW')||keys.has('ArrowUp')) - (keys.has('KeyS')||keys.has('ArrowDown'))
        );
        if (v.lengthSq() > 0){
          v.normalize().multiplyScalar((this.speed/3.6)*dt);
          const prev = this.obj.position.clone();
          this.obj.position.x += v.x * 4; // scale to tune feel
          this.obj.position.z -= v.y * 4;

          // face moving direction
          const ang = Math.atan2(v.x, -v.y);
          if (!isNaN(ang)) this.obj.rotation.y = ang;

          if (collidesWithBuildings(this.obj.position, 0, .3, .3)){
            this.obj.position.copy(prev);
          }
        }
      }
    }
  }

  const car = makeCar();
  const ped = makePed();
  let onFoot = false;
  modeEl.textContent = onFoot ? 'On Foot' : 'Driving';

  // ----- Missions (drive to beacon)
  let goals = 0, goalTarget = 5;
  let beacon = null;

  function spawnBeacon(){
    if (beacon) scene.remove(beacon);
    // pick an intersection roughly within ring [60, 200]
    function snap(n, step){ return Math.round(n/step)*step; }
    let x=0,z=0, tries=0;
    do {
      x = snap(MathUtils.randFloatSpread(360), world.block);
      z = snap(MathUtils.randFloatSpread(360), world.block);
      tries++;
    } while ((Math.hypot(x,z) < 60 || Math.hypot(x,z) > 220) && tries < 50);

    const geo = new SphereGeometry(1.2, 20, 20);
    const mat = new THREE.MeshStandardMaterial({ color:0x10b981, emissive:0x064e3b, emissiveIntensity:0.6 });
    beacon = new Mesh(geo, mat);
    beacon.position.set(x, 1.2, z);
    beacon.userData.type = 'beacon';
    scene.add(beacon);
    missionEl.textContent = `Mission: Drive to the green beacon (${goals}/${goalTarget})`;
  }
  spawnBeacon();

  function checkBeacon(){
    const p = (onFoot ? ped.obj.position : car.obj.position);
    if (!beacon) return;
    if (p.distanceTo(beacon.position) < 4){
      goals++;
      missionEl.textContent = `Mission: Drive to the green beacon (${goals}/${goalTarget})`;
      scene.remove(beacon); beacon=null;
      if (goals >= goalTarget){
        notice(`Great job! Missions complete. Press E / ACT to toggle mode and free roam.`);
        goalTarget += 5; goals = 0;
      }
      setTimeout(spawnBeacon, 400);
    }
  }

  function notice(msg, ms=2200){
    noticeEl.textContent = msg;
    clearTimeout(noticeEl._t);
    noticeEl._t = setTimeout(()=>noticeEl.textContent='', ms);
  }

  // ----- Camera follow
  function updateCamera(dt){
    const target = onFoot ? ped.obj : car.obj;
    // behind & above
    const look = target.position.clone();
    const yaw = onFoot ? target.rotation.y : car.heading;
    const back = new Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const offset = back.clone().multiplyScalar(10);
    const desired = target.position.clone().add(offset).add(new Vector3(0, 6, 0));
    camera.position.lerp(desired, 1 - Math.pow(0.001, dt)); // smooth
    camera.lookAt(look.x, look.y+1.2, look.z);
  }

  // ----- Enter/Exit logic
  function canEnter(){
    return ped.obj.position.distanceTo(car.obj.position) < 3;
  }

  function toggleMode(){
    if (onFoot){
      // try enter car
      if (canEnter()){
        onFoot = false;
        modeEl.textContent = 'Driving';
        notice('Entered vehicle.');
      } else {
        notice('Move closer to the car to enter.');
      }
    } else {
      // exit car: drop ped to the left side
      const yaw = car.heading;
      ped.obj.position.copy(car.obj.position).add(new Vector3(Math.cos(yaw)*-1.2, 0, Math.sin(yaw)*1.2));
      ped.obj.rotation.y = yaw + Math.PI/2;
      onFoot = true;
      modeEl.textContent = 'On Foot';
      notice('Exited vehicle.');
    }
  }

  // action handler
  function handleAction(){
    if (input.action){
      toggleMode();
      input.action = false;
    }
  }

  // ----- Main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min((now - last)/1000, 0.05);
    last = now;

    if (onFoot){
      ped.update(dt);
      // car idles friction
      car.vel.y *= (1 - Math.min(1, car.drag*dt));
    } else {
      car.update(dt);
    }

    handleAction();
    updateCamera(dt);
    checkBeacon();

    // HUD
    speedEl.textContent = Math.round((onFoot ? (ped.speed*(keys.has('KeyW')||keys.has('ArrowUp')?1:0)) : car.getSpeedKmh()));
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Resize
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }, {passive:true});

  // Quality-of-life
  document.addEventListener('visibilitychange', ()=>{ last = performance.now(); });

  // Start message
  notice('Drive to the green beacon. Press E / ACT near car to switch.');
})();
</script>
</body>
</html>
